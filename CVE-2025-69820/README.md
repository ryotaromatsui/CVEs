## CVE-2025-69820

### Description:
Directory Traversal vulnerability in Beam beta9 v.0.1.552 allows a remote attacker to read or modify sensitive information via the `joinCleanPath` function.

### Impact:
Attackers could potentially access files in the cloud that were not originally intended by the developers.

### Details:
The module responsible for creating Presigned URLs incorrectly normalizes the user-provided ObjectKey. When generating a Presigned URL, the raw ObjectKey from the user should be used directly. However, the current code sanitizes the key using `joinCleanPath` before passing it to the presign client.
This vulnerability allows an attacker to provide a specially crafted ObjectKey to access (GET) or overwrite (PUT) objects that are not meant to be accessible. This could lead to unauthorized data access or modification.

`beta9/pkg/abstractions/volume/multipart.go`L45-51
```go
func joinCleanPath(parts ...string) string {
	for i, part := range parts {
		parts[i] = filepath.Clean(part)
	}
	return filepath.Join(parts...)
}
```

`beta9/pkg/abstractions/volume/multipart.go` L60~71~113~139
```go
func (s *GlobalVolumeService) CreatePresignedURL(ctx context.Context, in *pb.CreatePresignedURLRequest) (*pb.CreatePresignedURLResponse, error) {
・・・
	var s3Client *s3.Client
	var presignClient *s3.PresignClient

	key := joinCleanPath(types.DefaultVolumesPrefix, authInfo.Workspace.Name, volume.ExternalId, in.VolumePath)
	bucket := s.config.BucketName

	if authInfo.Workspace.StorageAvailable() {
		storageClient, err := clients.NewWorkspaceStorageClient(ctx, authInfo.Workspace.Name, authInfo.Workspace.Storage)
		if err != nil {
			return &pb.CreatePresignedURLResponse{
				Ok:     false,
				ErrMsg: err.Error(),
			}, nil
		}

		s3Client = storageClient.S3Client()
		presignClient = storageClient.PresignClient()
		key = joinCleanPath(types.DefaultVolumesPrefix, volume.ExternalId, in.VolumePath)
		bucket = storageClient.BucketName()
	} else {
		s3Client = s.getS3Client()
		presignClient = s3.NewPresignClient(s3Client)
	}
・・・
	switch in.Method {
	case pb.PresignedURLMethod_HeadObject:
		req, err = presignClient.PresignHeadObject(
			ctx, &s3.HeadObjectInput{
				Bucket: aws.String(bucket),
				Key:    aws.String(key),
			},
			options...,
		)
	case pb.PresignedURLMethod_GetObject:
		req, err = presignClient.PresignGetObject(
			ctx, &s3.GetObjectInput{
				Bucket: aws.String(bucket),
				Key:    aws.String(key),
			},
			options...,
		)
	case pb.PresignedURLMethod_PutObject:
		req, err = presignClient.PresignPutObject(
			ctx, &s3.PutObjectInput{
				Bucket:        aws.String(bucket),
				Key:           aws.String(key),
				ContentType:   aws.String(in.Params.ContentType),
				ContentLength: aws.Int64(int64(in.Params.ContentLength)),
			},
			options...,
		)
```

### Proof-of-Concept Exploit
- TBD